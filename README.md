# leetcode-text
92.Reverse Linked List II
Runtime: 4 ms, faster than 67.04% of C online submissions for Reverse Linked List II.
Memory Usage: 6.9 MB, less than 100.00% of C online submissions for Reverse Linked List II.

93.IPaddress
Runtime: 4 ms, faster than 69.23% of C online submissions for Restore IP Addresses.
Memory Usage: 7.8 MB, less than 100.00% of C online submissions for Restore IP Addresses.

94.

Pop_oder
题目描述:
已知某一个字母序列，把序列中的字母按出现顺序压入一个栈，在入栈的任意过程中，允许栈中的字母出栈，求所有可能的出栈顺序

输入描述:
字符串，如：abc
输出描述:
可能的出栈顺序，每行一种顺序

Optimal_Binary_Tree
题目描述：
有一个节点数组，需要创建一棵最优二叉树，即每个节点的权值乘以节点在树中的长度，然后相加得到的值最小。

输入描述:
第一行为数据个数 第二行为权值（整数）
输出描述:
构建的二叉树

Match_String
题目描述:
函数match检查字符串str是否匹配模板pattern，匹配则返回0，否则返回-1。模板支持普通字符(a-z0-9A-Z)及通配符?和*。普通字符匹配该字符本身，?匹配任意一个字符，*匹配任意多个任意字符。

输入描述:
第一行为输入串 第二行为模板串
输出描述:
匹配输出match,不匹配输出unmatch

Reverse_Binary
题目描述:
编写函数reverse，将val(32位无符号整数)的二进制位反序。比如，如果val的二进制表示为1011000011111111，反序后val的二进制表示为1111111100001101。

输入描述:
16进制的一个无符号整数
输出描述:
16进制的一个无符号整数

Set_Traversal
题目描述:
有K种颜色的小球(K<=10)，每种小球有若干个，总数小于100个。
现在有一个小盒子，能放N个小球(N<=8)，现在要从这些小球里挑出N个小球，放满盒子。
想知道有哪些挑选方式。注：每种颜色的小球之间没有差别。
请按数字递增顺序输出挑选小球的所有方式。
如有3种颜色，每种颜色小球的个数分别为a:1,b:2,c:3，挑出3个小球的挑法有：
003,012,021,102,111,120

输入描述:
第一行两个数字K N，分别表示小球种类数目和挑选的小球个数
第二行开始为每种小球的数目，共N行数据
输出描述:
输出所有可行的挑选方案，按升序排列

Connection_Track
题目描述:
网络上有很多数据包，有些数据包是属于某些TCP连接的。一条TCP连接可以有很多个数据包。每个条TCP连接可以由4个数据唯一确定：源IP、源端口、目的IP、目的端口。这其中源IP、目的IP的取值范围是0.0.0.0---255.255.255.255，是4个0—255的整数，由点号分割；而源端口、目的端口的取值范围是0—65535，是一个整数。每个数据包都带有这四个信息(源IP、源端口、目的IP、目的端口)。如果两个数据包的源IP、源端口、目的IP、目的端口全部相同，则它们属于同一条TCP连接；否则他们不属于同一条TCP连接。
现在某Sangfor安全设备检测到网络上的多个数据包，并且知道这些数据包的源IP、源端口、目的IP、目的端口 这四个信息，请你判断这些数据包分别属于哪一条TCP连接。如果这个数据包属于以前出现过的某条连接，则请你输出这条TCP连接的编号；如果这个数据包属于新的TCP连接，则请你给这个TCP连接分配并输出一个新的TCP连接编号。新的TCP连接编号从1开始分配，每次加一。

输入描述:
第一行一个正整数n(n<=100,000)，表示有n个数据包;
接下来n行，每行4个数据，表示这个数据包的源IP、源端口、目的IP、目的端口。
输出描述:
输出n行，每行一个正整数，表示这个数据包所在的TCP连接的编号

Checkerboard
题目描述:
8x8的棋盘上，布有黑白两色棋子，白子先下，当白子下N手后，棋盘上最多有可能留下多少颗白子？
下法规则：
1.每次落子后，以该棋子为中心的8个方向(米字形的8条直线)，如果有同色棋子，
且两个同色棋子之间连续排列着若干个异色棋子，无空白及同色棋子。则，这次落子可以把这些夹在中间的异色棋子全部翻色（即黑变白，白变黑）；
2. 黑白子交错落子；
3. 如果一个位置上有棋子，不能继续在该位置上落子；
4. 如果一个位置上落子后，不能翻对手的棋子，则该位置不能落子；

输入描述:
第一行为白子需要走的步数

接下来8行数据，指明棋盘上的棋子状态，其中1为黑子，2为白子，0为空位置
输出描述:
白子下完N手后，棋盘上的白子个数的最大可能。

Place_Cuboid
题目描述:
一个长方体，长宽高分别为x,y,z，都为自然数。
现在要把若干个相同的立方体摆成高为N的一根柱形体。
每层摆1个，如果两种摆法的高度是一样的，则认为这两种摆法等价，所以每层只有三种摆法。
求一共有多少种摆法。

输入描述:
第一行为一个数字N，N>=1且N<=100，表示要摆放的高度
第二行为长方体的长宽高,x、y、z都为无符号整数，按升序排列。
输出描述:
摆法总数，已知该总数会小于10000000

IPSegment
题目描述:
一个数字段由首尾两个数字标识，表示一个自然数集合，
比如数字段[beg, end)表示从beg到end之间的所有自然数，
包含beg，但不包含end。
有若干个数字段，这些数字段之间可能有重叠，
怎么把这些数字段合并去重，用最少个数的数字段来表示。
合并前后，整个集合包含的数字不发生变化。

输入描述:
第一行为数字N，表示接下来有N个数字段(N<=100000)
第二行开始一共有N行，每行两个数字，分别表示一个数字段的beg和end
(beg和end为无符号32位整数)。
输出描述:
合并去重后形成的数字段集合，按升序排列。

Dictionary_Phrase
题目描述:
判断所给的字符串是否由所给的词典中的若干个词组成。
如已知词典["code", "sangfor", "org"]
则字符串"codesangfororg" 由上述词典组成，
字符串"codesangforsangfororg" 也由上述词典组成，
但字符串"sangforcom" 则不由上述词典组成。

输入描述:
第一行一个数字K 表示词典个数
后面若干行则为具体的输入词典，一个词典一行
最后一行输入待判定的字符串
输出描述:
若字符串为对应的词典组成，则输出yes，否则输出no

Optimal_Path
题目描述:
有A、B、C、D、E、F 6个城市，假如某人驾车，A到B需要12个小时，C到D需要3个小时，B到C需要10个小时，D到E需要4个小时，C到F需要6个小时，F到A需要16个小时，E到F需要2个小时，B到F需要7个小时，C到E需要5个小时，求任意给定的两地之间的最佳驾驶路线。

输入描述:
ABCDEF中任意两个字母，以空格隔开
输出描述:
第一行输出最短时间
第二行输出最佳路线

LayerTree_to_Pre
题目描述:
现输入二叉树层次遍历序列，请输出其前序遍历序列。

输入描述:
第一行输入数字N为层次遍历结点个数
接下来以层次遍历顺序输入N行节点的值（空用"#"代替）
输出描述:
先序遍历结果（空打印为"#"）

LRU
题目描述:
设计实现一个LRU（Least Recently Used）缓存器
LRU有如下两个方法：
int get(int key) - 从缓存中取值，返回key对应的value（值总是一个正数）， 如不存在返回 -1。
void set(int key, int value) - 往缓存中存键值对。 当缓存达到容量限制时，令“最近最少使用” 的键值对失效。
根据输入内容操作该LRU缓存器，输出LRU缓存器每个get的结果。

输入描述:
第一行输入两个数N L（N>0, L>0），N为缓存器容量，L为接下来输入的行数
接下来输入L行：
(1) 对应get操作，输入格式为"g %d"；
(2) 对应set操作，输入格式为"s %d %d"，前一个数为key，后一个为value。
输出描述:
输出每次get操作的返回值，一次一行。

Bit Aligned
题目描述：
编写函数align_n，将size的低n位（即：0到n-1位）清零，如果清零前size的低n位不为全零，则在第n位上加1。n满足32>n>0。
align_n的函数原型：
unsigned int align_n(unsigned int size, int n);

输入描述：
size（十六进制）,n（十进制）
输出描述：
align_n的运算结果（十六进制）

Chess
题目描述：
函数calc计算围棋盘位置(x,y)处的棋子还有多少口气。
某个位置处的棋子还有多少口气的计算方法(简化计算)：从该位置出发，向四个方向遍历，允许拐弯，但不允许走斜线。如果遇到边线和对方棋子，则认为不能继续往前走。遍历完成后统计遍历过程中遇到的未落子的位置个数，该位置个数即出发点棋子的气的数目。

enum color {
NONE, WHITE, BLACK,         // 棋子颜色，NONE表示未落子
};
struct weiqi {
enum color board[19][19];   // 棋盘上每个位置的落子
};
int calc(struct weiqi *wq, int x, int y){}

输入描述：
第1-19行数据是棋盘上棋子的颜色数据。0表示未落子，1表示白子，2表示黑子。 第1行最左边位置的坐标是(0,0)，第1行第2列的坐标是(1,0)，第2行第1列的坐标是(0,1)，依此类推。 第20行数据是起始坐标(x,y)
输出描述：
位置(x,y)处的棋子还有多少口气，如果该位置未落子，则输出-1

Dictionary_Encryption_Decryption
题目描述：
已知一段消息由26个小写字母和0-9这10个数字构成。
现在需要设计一种简单的字典加密法和解密法，把消息加密为简单密文，或者把一段密文还原为原文。

说明：
本字典加解密算法中用的字典由36个字符组成，分别为：abcdefghijklmnopqrstuvwxyz0123456789，加密前、后的字符串也是由这36个字符组成。
输入字典格式为36个字符组成的串D。串中每个字符表示A中对应位置处的字符加密后的结果，如
A：abcdefghijklmnopqrstuvwxyz0123456789
D：fghijklmnopqrstuvwxyz0123456789abcde
表示a=>f,b=>g...0=>5...9=>e
请根据输入对字符串进行加密或解密。

输入描述：
第一行是字典，由36个字符数字组成，具体含义见题目中的相关说明。
第二行是模式，1表示加密，0表示解密。
第三行是待加密字符串或待解密字符串，长度小于10000。
输出描述：
使用对应字典加密或解密后的字符串。

Goldtime
题目描述：
每个人的职业生涯状态有起有落，程序员也如此。
我们对程序员的状态做一个简化，单纯用缺陷密度来衡量一个程序员一天的状态。如果这一天的缺陷密度比平均值高，则认为他这一天的状态差，高出越多，认为状态越差。比平均值低，则认为状态好，低得越多，认为状态越好。人的状态是可以叠加的，如果两个连续时间段的缺陷密度加起来低于平均值，则认为这两个时间段合起来状态是好的。
给定一个程序员很长一段时间中各个时间片段的缺陷密度(V)与平均值(A)的差值(D=V-A)，求出该程序员的黄金时间段的缺陷密度差值D的累加和。
缺陷密度差值D如果为正数，表明缺陷密度高于平均值，如果为负数，表明缺陷密度低于平均值。
所谓黄金时间段，指一个连续时间段，这段时间的缺陷密度与平均值的差值D累加起来，在各种划分方法中，是最小的，也即状态是最好的。

输入描述：
第一行给出一个正整数T，表示一共有T个时间段。(1<=T<10000000)
接下来T行数据，每行数据为一个整数，表示这个时间段缺陷密度与平均值的差值(D)。
输出描述：
输出黄金时间段内缺陷密度差值D的累加和(已知D不超过32位整数的表达范围)。

Percent_Decode
题目描述：
在URL字符串中，如果百分号%后面跟了两个十六进制数字，那么它表示相应ASCII值所对应的字符，如%2F表示'/'，%32表示'2'。%编码还可以进行嵌套，如%%32F可以解码成%2F，再进一步解码成/。如果没有任何百分号后面跟的是两个十六进制数字则无法再进行解码。
现在有一系列的URL，小强希望你帮忙进行百分号解码，直到无法再解码为止。

输入描述：
第一行一个正整数T（T<=10），表示T个测试样例；
对于每个测试样例，
输入字符串s，字符串不包含空白符且长度小于100,000。
输出描述：
输出T行，每行一个字符串，表示解码后的结果。